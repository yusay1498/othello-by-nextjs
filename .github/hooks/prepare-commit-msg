#!/bin/sh
#
# Git hook to help generate commit messages with GitHub Copilot
# このhookはGitHub Copilotと連携して、より説明的なコミットメッセージを生成します
#

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

# Only run for regular commits (not merge, squash, etc.)
if [ -z "$COMMIT_SOURCE" ] || [ "$COMMIT_SOURCE" = "message" ]; then
  # Get the diff of staged changes
  STAGED_DIFF=$(git diff --cached --stat)
  
  # ステージされたファイルの状態を取得
  STAGED_STATUS=$(git diff --cached --name-status)
  
  # ファイル数をカウント（空行を除外）
  FILE_COUNT=$(echo "$STAGED_STATUS" | grep -v "^$" | wc -l | tr -d ' ')

  # If there are staged changes and the commit message is empty or contains only comments
  if [ -n "$STAGED_DIFF" ] && { [ ! -s "$COMMIT_MSG_FILE" ] || ! grep -q '^[[:space:]]*[^#[:space:]]' "$COMMIT_MSG_FILE"; }; then
    TEMP_FILE="${COMMIT_MSG_FILE}.tmp"
    cp "$COMMIT_MSG_FILE" "$TEMP_FILE" 2>/dev/null || true

    # 詳細な変更内容を取得（Copilotへのコンテキスト情報）
    # 大容量リポジトリでのメモリ効率化のためパイプで直接絞り込む
    FULL_DIFF=$(git diff --cached --no-color | head -500)
    
    # 追加された行から主要な変更を抽出
    ADDED_LINES=$(echo "$FULL_DIFF" | grep "^+" | grep -v "^+++" | head -50)
    REMOVED_LINES=$(echo "$FULL_DIFF" | grep "^-" | grep -v "^---" | head -30)
    
    # 変更の種類を検出するための詳細情報
    ADDED_FUNCTIONS=""
    ADDED_CLASSES=""
    ADDED_IMPORTS=""
    CONFIG_CHANGES=""
    
    # TypeScript/JavaScript関数の追加を検出
    # パターン1: 通常の関数宣言 (function foo)
    # パターン2: アロー関数 (const foo = () => / const foo = async () =>)
    # パターン3: export付き関数
    FUNC_PATTERN_NORMAL="^\\+\\s*(export\\s+)?(async\\s+)?function\\s+[a-zA-Z_]"
    FUNC_PATTERN_ARROW="^\\+\\s*(export\\s+)?const\\s+[a-zA-Z_][a-zA-Z0-9_]*\\s*=\\s*(async\\s+)?\\("
    ADDED_FUNCTIONS=$(echo "$ADDED_LINES" | grep -E "$FUNC_PATTERN_NORMAL|$FUNC_PATTERN_ARROW" | sed 's/^+//' | head -5)
    
    # クラス/コンポーネントの追加を検出
    # パターン1: クラス宣言 (class Foo)
    # パターン2: 大文字で始まる関数（Reactコンポーネント）
    CLASS_PATTERN="^\\+\\s*(export\\s+)?(default\\s+)?class\\s+[A-Z]"
    COMPONENT_PATTERN="^\\+\\s*(export\\s+)?(default\\s+)?function\\s+[A-Z][a-zA-Z]*\\s*\\("
    ADDED_CLASSES=$(echo "$ADDED_LINES" | grep -E "$CLASS_PATTERN|$COMPONENT_PATTERN" | sed 's/^+//' | head -3)
    
    # React コンポーネントの検出
    REACT_COMPONENTS=$(echo "$ADDED_LINES" | grep -E "^\\+\\s*return\\s*\\(|^\\+\\s*<[A-Z][a-zA-Z]*|^\\+\\s*(export\\s+)?(default\\s+)?function\\s+[A-Z]" | head -3)
    
    # インポートの追加を検出
    ADDED_IMPORTS=$(echo "$ADDED_LINES" | grep -E "^\\+\\s*import\\s+" | sed 's/^+//' | head -5)
    
    # 設定変更を検出
    CONFIG_CHANGES=$(echo "$ADDED_LINES" | grep -E "^\\+.*\"[a-zA-Z._-]+\"\\s*:" | head -5)
    
    # フィックス/バグ修正のパターンを検出
    FIX_PATTERNS=$(echo "$ADDED_LINES" | grep -iE "fix|bug|error|issue|correct|resolve" | head -3)
    
    # 初期メッセージを生成
    INITIAL_MSG=""
    
    if [ "$FILE_COUNT" -eq 1 ]; then
      STATUS=$(echo "$STAGED_STATUS" | awk '{print $1}')
      FILE_PATH=$(echo "$STAGED_STATUS" | awk '{print $NF}')
      FILE_NAME=$(basename "$FILE_PATH")
      FILE_EXT="${FILE_NAME##*.}"
      DIR_NAME=$(dirname "$FILE_PATH")
      
      case "$STATUS" in
        A)
          # 新規ファイル: ファイルの目的を推測
          if echo "$FILE_PATH" | grep -qE "test|spec"; then
            # テストファイル: テスト対象を特定
            TEST_SUBJECT=$(echo "$ADDED_LINES" | grep -E "describe\\(|test\\(|it\\(" | head -1 | sed -E "s/.*['\"]([^'\"]+)['\"].*/\1/" | head -1)
            if [ -n "$TEST_SUBJECT" ]; then
              INITIAL_MSG="Add tests for $TEST_SUBJECT"
            else
              INITIAL_MSG="Add tests for ${FILE_NAME%.*}"
            fi
          elif echo "$FILE_PATH" | grep -q "components"; then
            # コンポーネント: コンポーネント名を抽出
            COMPONENT_NAME=$(echo "$ADDED_LINES" | grep -E "^\\+\\s*(export\\s+)?(default\\s+)?function\\s+[A-Z]" | head -1 | sed -E 's/.*function\s+([A-Z][a-zA-Z]*).*/\1/')
            if [ -n "$COMPONENT_NAME" ]; then
              INITIAL_MSG="Add $COMPONENT_NAME component"
            else
              INITIAL_MSG="Add ${FILE_NAME%.*} component"
            fi
          elif echo "$FILE_PATH" | grep -q "hooks"; then
            HOOK_NAME=$(echo "$ADDED_LINES" | grep -E "^\\+\\s*(export\\s+)?(const|function)\\s+use[A-Z]" | head -1 | sed -E 's/.*(use[A-Z][a-zA-Z]*).*/\1/')
            if [ -n "$HOOK_NAME" ]; then
              INITIAL_MSG="Add $HOOK_NAME hook"
            else
              INITIAL_MSG="Add ${FILE_NAME} hook"
            fi
          elif echo "$FILE_PATH" | grep -qE '(^|/)lib(/|$)|(^|/)utils(/|$)'; then
            UTIL_FUNC=$(echo "$ADDED_LINES" | grep -E "^\\+\\s*(export\\s+)?(const|function)\\s+[a-z]" | head -1 | sed -E 's/.*(const|function)\s+([a-zA-Z_][a-zA-Z0-9_]*).*/\2/')
            if [ -n "$UTIL_FUNC" ]; then
              INITIAL_MSG="Add $UTIL_FUNC utility function"
            else
              INITIAL_MSG="Add utility functions in $FILE_NAME"
            fi
          elif echo "$FILE_NAME" | grep -qiE "readme|doc"; then
            INITIAL_MSG="Add documentation"
          elif [ "$FILE_EXT" = "md" ]; then
            # Markdownファイル: タイトルを取得
            MD_TITLE=$(echo "$ADDED_LINES" | grep -E "^\\+#\\s+" | head -1 | sed 's/^+#\s*//')
            if [ -n "$MD_TITLE" ]; then
              INITIAL_MSG="Add documentation for $MD_TITLE"
            else
              INITIAL_MSG="Add $FILE_NAME documentation"
            fi
          elif [ "$FILE_EXT" = "json" ]; then
            INITIAL_MSG="Add $FILE_NAME configuration"
          else
            INITIAL_MSG="Add $FILE_NAME"
          fi
          ;;
        M)
          # 修正: 変更内容から推測
          
          # 追加された行数と削除された行数をカウント（空行を除外）
          ADDED_COUNT=$(echo "$ADDED_LINES" | grep -v "^$" | wc -l | tr -d ' ')
          REMOVED_COUNT=$(echo "$REMOVED_LINES" | grep -v "^$" | wc -l | tr -d ' ')
          
          # 関数の追加を優先的に検出
          if [ -n "$ADDED_FUNCTIONS" ]; then
            FUNC_NAME=$(echo "$ADDED_FUNCTIONS" | head -1 | sed -E 's/.*(function|const)\s+([a-zA-Z_][a-zA-Z0-9_]*).*/\2/')
            if [ -n "$FUNC_NAME" ]; then
              INITIAL_MSG="Add $FUNC_NAME function to $FILE_NAME"
            else
              # 関数名の抽出に失敗した場合はデフォルトのメッセージを設定
              INITIAL_MSG="Update $FILE_NAME"
            fi
          # コンポーネントの修正
          elif [ -n "$REACT_COMPONENTS" ] && [ -n "$ADDED_CLASSES" ]; then
            COMPONENT=$(echo "$ADDED_CLASSES" | head -1 | sed -E 's/.*function\s+([A-Z][a-zA-Z]*).*/\1/')
            INITIAL_MSG="Add $COMPONENT component in $FILE_NAME"
          # フィックスパターンの検出
          elif [ -n "$FIX_PATTERNS" ]; then
            INITIAL_MSG="Fix issue in $FILE_NAME"
          # インポートのみの追加
          elif [ -n "$ADDED_IMPORTS" ] && [ "$ADDED_COUNT" -lt 5 ]; then
            INITIAL_MSG="Add imports to $FILE_NAME"
          # 設定変更
          elif [ -n "$CONFIG_CHANGES" ]; then
            CONFIG_KEY=$(echo "$CONFIG_CHANGES" | head -1 | sed -E 's/.*"([a-zA-Z._-]+)".*/\1/')
            if [ -n "$CONFIG_KEY" ]; then
              INITIAL_MSG="Update $CONFIG_KEY in $FILE_NAME"
            else
              INITIAL_MSG="Update configuration in $FILE_NAME"
            fi
          # リファクタリング（削除と追加が同程度）
          elif [ "$REMOVED_COUNT" -gt 5 ] && [ "$ADDED_COUNT" -gt 5 ]; then
            INITIAL_MSG="Refactor $FILE_NAME"
          # ドキュメント更新
          elif [ "$FILE_EXT" = "md" ]; then
            INITIAL_MSG="Update $FILE_NAME documentation"
          else
            # デフォルト: ディレクトリ構造を含める
            if [ "$DIR_NAME" != "." ]; then
              SHORT_DIR=$(echo "$DIR_NAME" | sed 's|.*/||')
              INITIAL_MSG="Update $FILE_NAME in $SHORT_DIR"
            else
              INITIAL_MSG="Update $FILE_NAME"
            fi
          fi
          ;;
        D)
          INITIAL_MSG="Remove $FILE_NAME"
          ;;
        R*)
          OLD_NAME=$(echo "$STAGED_STATUS" | awk '{print $2}' | xargs basename)
          NEW_NAME=$(echo "$STAGED_STATUS" | awk '{print $3}' | xargs basename)
          INITIAL_MSG="Rename $OLD_NAME to $NEW_NAME"
          ;;
      esac
    else
      # 複数ファイルの場合: 共通のパターンを探す
      
      # ファイル状態をカテゴリ別にカウント（一度のパースで全て取得）
      ADDED_FILES=$(echo "$STAGED_STATUS" | grep -c "^A" || echo "0")
      MODIFIED_FILES=$(echo "$STAGED_STATUS" | grep -c "^M" || echo "0")
      DELETED_FILES=$(echo "$STAGED_STATUS" | grep -c "^D" || echo "0")
      
      # ディレクトリ情報を一度だけ取得（スペースを含むパスにも対応）
      FILE_DIRS=$(echo "$STAGED_STATUS" | awk '{print $NF}' | while IFS= read -r line; do dirname "$line"; done)
      COMMON_DIR=$(echo "$FILE_DIRS" | sort -u | head -1)
      UNIQUE_DIRS=$(echo "$FILE_DIRS" | sort -u | wc -l | tr -d ' ')
      
      # コンポーネントとテストのセット（test/specパターンを厳密にマッチ）
      if echo "$STAGED_STATUS" | grep -qE "components" && echo "$STAGED_STATUS" | awk '{print $NF}' | grep -qE '(^|/)(test|spec|__tests__)/|[._-](test|spec)\.[a-z]+$'; then
        # 新規追加のコンポーネントかどうかを確認
        if echo "$STAGED_STATUS" | grep -q "^A.*components"; then
          COMPONENT_FILE=$(echo "$STAGED_STATUS" | grep "^A.*components" | head -1 | awk '{print $NF}' | while IFS= read -r line; do basename "$line"; done | sed 's/\..*//')
          INITIAL_MSG="Add $COMPONENT_FILE component with tests"
        else
          COMPONENT_FILE=$(echo "$STAGED_STATUS" | grep "components" | head -1 | awk '{print $NF}' | while IFS= read -r line; do basename "$line"; done | sed 's/\..*//')
          INITIAL_MSG="Update $COMPONENT_FILE component with tests"
        fi
      # 全て同じディレクトリの場合
      elif [ "$UNIQUE_DIRS" -eq 1 ]; then
        DIR_NAME=$(basename "$COMMON_DIR")
        if [ "$ADDED_FILES" -gt 0 ] && [ "$MODIFIED_FILES" -eq 0 ]; then
          INITIAL_MSG="Add files to $DIR_NAME"
        elif [ "$DELETED_FILES" -gt 0 ] && [ "$ADDED_FILES" -eq 0 ]; then
          INITIAL_MSG="Remove files from $DIR_NAME"
        else
          INITIAL_MSG="Update $DIR_NAME"
        fi
      # テストファイルのみ（test/specを厳密にマッチ）
      elif echo "$STAGED_STATUS" | awk '{print $NF}' | grep -qE '(^|/)(test|spec|__tests__)/|[._-](test|spec)\.[a-z]+$' && [ "$FILE_COUNT" -le 3 ]; then
        INITIAL_MSG="Update tests"
      # ドキュメントのみ（.mdファイル）
      elif echo "$STAGED_STATUS" | awk '{print $NF}' | grep -qiE "\.md$" && [ "$FILE_COUNT" -le 3 ]; then
        INITIAL_MSG="Update documentation"
      # 設定ファイルのみ（config, json, yaml, yml）
      elif echo "$STAGED_STATUS" | awk '{print $NF}' | grep -qE "(config|\.json$|\.yaml$|\.yml$)" && [ "$FILE_COUNT" -le 3 ]; then
        INITIAL_MSG="Update configuration files"
      else
        # より詳細な説明を生成
        if [ "$ADDED_FILES" -gt 0 ] && [ "$MODIFIED_FILES" -eq 0 ] && [ "$DELETED_FILES" -eq 0 ]; then
          INITIAL_MSG="Add $ADDED_FILES new files"
        elif [ "$MODIFIED_FILES" -gt 0 ] && [ "$ADDED_FILES" -eq 0 ] && [ "$DELETED_FILES" -eq 0 ]; then
          INITIAL_MSG="Update $MODIFIED_FILES files"
        elif [ "$DELETED_FILES" -gt 0 ] && [ "$ADDED_FILES" -eq 0 ] && [ "$MODIFIED_FILES" -eq 0 ]; then
          INITIAL_MSG="Remove $DELETED_FILES files"
        else
          INITIAL_MSG="Update $FILE_COUNT files"
        fi
      fi
    fi

    # 詳細なコード変更のサマリーを生成（Copilot用）
    CODE_CONTEXT=""
    
    if [ -n "$ADDED_FUNCTIONS" ]; then
      CODE_CONTEXT="$CODE_CONTEXT
# 追加された関数/メソッド:
$(echo "$ADDED_FUNCTIONS" | head -3 | sed 's/^/# + /')"
    fi
    
    if [ -n "$ADDED_CLASSES" ]; then
      CODE_CONTEXT="$CODE_CONTEXT
# 追加されたクラス/コンポーネント:
$(echo "$ADDED_CLASSES" | head -3 | sed 's/^/# + /')"
    fi
    
    if [ -n "$ADDED_IMPORTS" ]; then
      CODE_CONTEXT="$CODE_CONTEXT
# 追加されたインポート:
$(echo "$ADDED_IMPORTS" | head -3 | sed 's/^/# + /')"
    fi

    # 主要な変更行を抽出（Copilotに詳細なコンテキストを提供）
    # 除外パターン:
    #   ^\\+\\s*$       - 空行
    #   ^\\+\\s*//      - 単一行コメント (//)
    #   ^\\+\\s*#       - シェル/Python コメント (#)
    #   ^\\+\\s*/\\*    - ブロックコメント開始 (/*)
    #   ^\\+\\s*\\*     - ブロックコメント継続 (*)
    KEY_CHANGES=$(echo "$ADDED_LINES" | grep -vE "^\\+\\s*$|^\\+\\s*//|^\\+\\s*#|^\\+\\s*/\\*|^\\+\\s*\\*" | head -10)

    # Write initial message and helpful context for Copilot
    cat > "$COMMIT_MSG_FILE" << EOF
$INITIAL_MSG
# ---------------------------------------------------------------
# GitHub Copilot コミットメッセージアシスタント
# ---------------------------------------------------------------
# 上記のメッセージを参考に、より説明的なメッセージに編集してください。
# Copilotが補完を提案します。
#
# コミットメッセージのガイドライン:
# - 1行目: 必ず先頭大文字の英語で記述
# - プレフィックス（feat:, fix: など）は不要
# - 変更内容を簡潔に記述
# - ピリオド、カンマ、接続詞はできるだけ避ける
# - 1文でかつ50文字以内に収める
#
# ステージされた変更 / Staged changes:
$(printf '%s\n' "$STAGED_DIFF" | head -20 | sed 's/^/# /')
$CODE_CONTEXT
#
# 主要な変更内容 / Key changes:
$(printf '%s\n' "$KEY_CHANGES" | head -10 | sed 's/^/# + /')
EOF

    if [ -f "$TEMP_FILE" ] && [ -s "$TEMP_FILE" ]; then
      printf '\n' >> "$COMMIT_MSG_FILE"
      cat "$TEMP_FILE" >> "$COMMIT_MSG_FILE"
      rm -f "$TEMP_FILE"
    fi
  fi
fi
